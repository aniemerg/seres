SERES: A Tool for Modeling Self-Replicating Systems

Seres is a knowledge‑base and simulation system for modeling a self‑replicating industrial ecosystem. The goal of the project is to model a system that can produce all of its components. In practice, that means representing the physical dependencies of a self‑replicating production chain, simulating their execution over time, and iteratively closing the gaps. The system is designed to make the self‑replication pathway concrete and computable rather than hypothetical.
At a high level, Seres has two layers: a knowledge base (KB) and a simulator. The KB captures the industrial “world model”: machines, processes, parts, recipes, and bills of materials (BOMs), along with their inputs, outputs, durations, and energy or resource requirements. The simulator executes that model: it advances time, runs processes, consumes inventory, and records outcomes. The two layers are tightly coupled but intentionally separated: the KB defines what is possible and required, while the simulator explores what happens when those constraints are exercised over time.
The KB is written in YAML and organized around a structured schema. It includes entries for materials, parts, processes, machines, and recipes, and it encodes how these elements depend on each other. It currently has over 5000 entries. A recipe depends on processes; processes depend on machines; machines depend on parts; parts depend on materials. These relationships define a dependency graph that the simulator can traverse and execute. The graph is not treated as complete or final; it is treated as a living structure, intended to be refined and expanded over time. A partial or coarse entry is often better than none, because it enables simulation to surface gaps and bottlenecks.
Because the KB can grow large and complex, it relies on indexing and validation tooling. The indexing layer scans KB files, builds an index of entities and their references, and checks for gaps, inconsistencies, and schema errors. The system recognizes a range of error classes, which are used to prioritize fixes and guide improvements. Most of the KB’s missing pieces are detected by automated checks and then addressed by targeted edits. The simulator also plays a key role in validation: when a user attempts to execute a recipe or process and fails, that missing dependency becomes a concrete, actionable gap in the KB.
The simulator is responsible for executing the KB’s abstractions in a time‑based environment. It models inventory, resource consumption, energy usage, and machine constraints. A process can only run if the required machines and inputs exist; a recipe can only complete if its sub‑processes can run; and the total time and energy used are tracked explicitly. The simulator maintains event logs and snapshots so that scenarios are reproducible, and it surfaces a record of what happened and why.
Both the KB and the simulator are designed to be used by AI agents. This allows for rapid growth of the KB and testing in simulation. The initial KB was created by “seeding” it with a small set of processes and machines and then having AI agents iteratively grow the KB by running validation, filling gaps, and fixing issues in an iterative fashion.
Seres explicitly targets the idea of closure: the ability to reproduce imported machines using in‑situ resources. The current KB includes many basic parts and structural elements—wires, metals, and simple components—while assuming more complex components (especially electronics) are imported. The near‑term goal is to extend scenarios so that they get closer to full closure, and to expand the KB so that fewer imports are required. The longer term goal is self‑replicaton where a simulated system can produce all of the machines and tools it needs to make another copy, using local resources to the extent possible.
To make scenarios reproducible and easier to share, the system includes “runbooks.” A runbook is a structured, human‑readable Markdown document that combines narrative with executable CLI commands. Runbooks provide a way to define simulations as a sequence of steps that are both understandable and reproducible. Each runbook can specify the simulation to use, reset state, import starting inventories, run processes, and advance time. The runbook format supports comments and explanations alongside the steps, which makes it a good medium for building up scenarios incrementally.
Runbooks serve as scenario artifacts: they encode a specific chain of steps, demonstrate assumptions, and can be iteratively refined as the KB becomes more complete. They are especially valuable for repeatable comparisons between different scenarios or KB revisions. Each runbook is both a test and a design document: it demonstrates what is currently possible, and it highlights what is still missing.
The immediate objective is to build longer and more complete scenarios, expose new gaps, and iterate on the KB so those gaps are resolved. At a conceptual level, the system is built around a few core abstractions and invariants. The KB’s entries describe physical dependencies that must be satisfied for a process to run. The simulator respects those dependencies, as well as time and energy constraints. The overall feedback loop is: encode a plausible dependency graph, simulate it, observe missing links or contradictions, and refine the KB and runbooks accordingly.
The hope for the project is that it can help better define some key questions about self-replicating systems, such as: What are the key aspects of a self-replicating system, what are the primary bottlenecks, how large is a self-replicating system, and so forth. 
